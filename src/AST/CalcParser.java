/* Generated By:JJTree&JavaCC: Do not edit this line. CalcParser.java */
package AST;
public class CalcParser/*@bgen(jjtree)*/implements CalcParserTreeConstants, CalcParserConstants {/*@bgen(jjtree)*/
  protected static JJTCalcParserState jjtree = new JJTCalcParserState();

/* *** Context-free grammar (EBNF) *** */


/* ** The start nonterminal and its productions. ** */
/* 
   The Start nonterminal corresponds to the concrete class Start.
   An Start node is generated by the notation "#Start" in the heading of
   the nonterminal method.
   
   JJTree maintains a stack of created nodes.
   The "#X" notation (when written in the heading like this) means:
   - create a new object of type X
   - pop the nodes that were created during this parse method and
     insert them as children to the new X node
   - then push the new X node
   
   For this nonterminal (Start), JJTree will pop the node created
   by the Exp() parse and insert it as a child to the Start node.
   
   During parsing, new nodes are kept track of by the JJTree internal stack
   as explained above. However, when an external client calls the parser
   (by calling the method of the nonterminal start symbol), it is useful
   to let that method return the resulting tree. For this reason, the
   start nonterminal is given a result type (Start) and the action
   "return jjtThis" is added to return a reference to the new Start node.
   
   The variable "jjtThis" refers to the new node created by the "#X" command
   (the Start node in this case).
   
   Other nonterminals need not return any nodes since they are not called
   by external clients. Therefore, they have no result type (void).
*/
  static final public Start Start() throws ParseException {
                       /*@bgen(jjtree) Start */
  Start jjtn000 = new Start(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Exp();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

/* ** Other nonterminals and their productions ** */

/* 
  Exp does not correspond to any concrete class. Therefore, there is no
  command "#Exp" in the heading of this nonterminal.
  
  If the list (of "*" and "/") is empty, this nonterminal does not change
  the stack of nodes. The top node of the stack will be the node constructed
  by the call to Factor().
  
  If the list is non-empty, the result of executing this nonterminal method
  will be to replace the top node of the stack with a left-associative tree
  rooted by a MulExp or DivExp node and consisting of possibly more MulExp
  and DivExp nodes.
  
  Here are the details of how the MulExp or DivExp tree is constructed:
  
  If there is one element in the list, a MulExp or a DivExp node will be
  created, and the two topmost nodes will be popped off the stack and
  inserted as children to the new MulExp/DivExp node. The new node is then
  pushed onto the stack. The notation "#MulExp(2)" means that precisely
  two nodes are popped. Simply writing "#MulExp" would have resulted in only
  popping one node. This is because the default scope of the "#X" command
  includes only the nodes within the current alternative.
  
  If there is more than one element in the list, the actions described
  above are repeated. The previous MulExp or DivExp node will be inserted as
  the first child of the new MulExp/DivExp node, and the node resulting from
  the Factor() parse will be inserted as the second child. Hence, the
  tree is built left-associative.
    
*/
  static final public void Exp() throws ParseException {
    Factor();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MUL:
      case 16:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MUL:
        jj_consume_token(MUL);
          MulExp jjtn001 = new MulExp(JJTMULEXP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        try {
          Factor();
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte001;}
          }
          if (jjte001 instanceof ParseException) {
            {if (true) throw (ParseException)jjte001;}
          }
          {if (true) throw (Error)jjte001;}
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
        break;
      case 16:
        jj_consume_token(16);
          DivExp jjtn002 = new DivExp(JJTDIVEXP);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        try {
          Factor();
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte002;}
          }
          if (jjte002 instanceof ParseException) {
            {if (true) throw (ParseException)jjte002;}
          }
          {if (true) throw (Error)jjte002;}
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  2);
          }
        }
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

/* 
  Factor does not correspond to any concrete class. Therefore, there is no
  command "#Factor" in the heading of this nonterminal.
  
  This nonterminal does not create any new AST node. The top node of
  the stack will be the node constructed by the call to LetExp(),
  FPLitExp() or IdExp().
*/
  static final public void Factor() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LET:
      LetExp();
      break;
    case FPLIT:
      FPLitExp();
      break;
    case ID:
      IdExp();
      break;
    case ASK:
      AskUserExp();
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
  LetExp corresponds to the concrete class LetExp.
  A new LetExp node is generated by the notation "#LetExp" in the heading.
  
  The two nodes created by the BindingList() and Exp() calls will be
  popped off the stack and inserted as children to the new LetExp node.
  Then, the new LetExp node is pushed onto the stack. 
*/
  static final public void LetExp() throws ParseException {
                        /*@bgen(jjtree) LetExp */
  LetExp jjtn000 = new LetExp(JJTLETEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LET);
      BindingList();
      jj_consume_token(IN);
      Exp();
      jj_consume_token(NI);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/*
  BindingList corresponds to the concrete generic list class List.
  A new List node is generated by the notation
  "#List" in the heading.
  
  All the Binding nodes created by the repeated Binding() calls will be
  popped off the stack and inserted as children to the new List node.
  Then, the new List node is pushed onto the stack.
  
*/
  static final public void BindingList() throws ParseException {
                            /*@bgen(jjtree) List */
  List jjtn000 = new List(JJTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Binding();
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_2;
        }
        jj_consume_token(COMMA);
        Binding();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/*
  Binding corresponds to the concrete class Binding.
  A new Binding node is generated by the notation "#Binding" in the heading.
  
  The two nodes created by the IdExp() and Exp() calls will be
  popped off the stack and inserted as children to the new Binding node.
  Then, the new Binding node is pushed onto the stack. 
*/
  static final public void Binding() throws ParseException {
                          /*@bgen(jjtree) Binding */
  Binding jjtn000 = new Binding(JJTBINDING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      IdExp();
      jj_consume_token(ASSIGN);
      Exp();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/*
  FPLitExp corresponds to the concrete class FPLitExp.
  A new FPLitExp node is generated by the notation "#FPLitExp" in
  the heading.
  
  Since this nonterminal contains no calls to other nonterminals, the
  new node will have no children. The new node is pushed onto the stack.
  
  The token resulting from parsing <FPLIT> is stored in a temporary
  variable "t" during parsing.
  The "t" variable is used for setting the FPLIT String field of the
  FPLitExp node (by calling the setFPLIT method). The jjtThis variable
  refers to the node created by the "#X" command, i.e., the new FPLitExp
  node in this case.
*/
  static final public void FPLitExp() throws ParseException {
 /*@bgen(jjtree) FPLitExp */
  FPLitExp jjtn000 = new FPLitExp(JJTFPLITEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(FPLIT);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setFPLIT(t.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/*
  IdExp corresponds to the concrete class IdExp.
  A new IdExp node is generated by the notation "#IdExp" in
  the heading.
  
  Since this nonterminal contains no calls to other nonterminals, the
  new node will have no children. The new node is pushed onto the stack.
  
  The token resulting from parsing <ID> is stored in a temporary
  variable "t" during parsing.
  The "t" variable is used for setting the ID String field of the
  IdExp node (by calling the setID method).  The jjtThis variable
  refers to the node created by the "#X" command, i.e., the new IdExp
  node in this case.
*/
  static final public void IdExp() throws ParseException {
 /*@bgen(jjtree) IdExp */
  IdExp jjtn000 = new IdExp(JJTIDEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(ID);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setID(t.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/*
  AskUserExp corresponds to the concrete class AskUserExp.
  A new AskUserExp node is generated by the notation "#AskUserExp"
  in the heading.
  
  The node created by the OptDefaultValue() call will be
  popped off the stack and inserted as a child to the new AskUserExp node.
  Then, the new AskUserExp node is pushed onto the stack. 
*/
  static final public void AskUserExp() throws ParseException {
                                /*@bgen(jjtree) AskUserExp */
  AskUserExp jjtn000 = new AskUserExp(JJTASKUSEREXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(ASK);
      jj_consume_token(USER);
      OptDefaultValue();
      jj_consume_token(QUESTION);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/*
  OptDefaultValue corresponds to the concrete generic optional class Opt.
  A new Opt node is generated by the notation "#Opt"
  in the heading.
  
  If the optional Exp() is called, the resulting node will be popped off
  the stack and inserted as a child to the new Opt node.
  Otherwise, Opt will have no children.
  Then, the new Opt node is pushed onto the stack. 
*/
  static final public void OptDefaultValue() throws ParseException {
                              /*@bgen(jjtree) Opt */
  Opt jjtn000 = new Opt(JJTOPT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LET:
      case ASK:
      case FPLIT:
      case ID:
        Exp();
        break;
      default:
        jj_la1[4] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public CalcParserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[5];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x11000,0x11000,0x8520,0x2000,0x8520,};
   }

  /** Constructor with InputStream. */
  public CalcParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public CalcParser(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new CalcParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public CalcParser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new CalcParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public CalcParser(CalcParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(CalcParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[17];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 5; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 17; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

                         }
